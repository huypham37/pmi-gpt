{"WSTG-INFO-01":"# Conduct Search Engine Discovery Reconnaissance for Information Leakage\n\n---\nid: WSTG-INFO-01\ntag: TA\n---\n\n## Brief Summary\n\nIn order for search engines to work, computer programs (or `robots`) regularly fetch data (referred to as [crawling](https://en.wikipedia.org/wiki/Web_crawler) from billions of pages on the web. These programs find web content and functionality by following links from other pages, or by looking at sitemaps. If a website uses a special file called `robots.\n","WSTG-INFO-02":"# Fingerprint Web Server\n\n---\nid: WSTG-INFO-02\ntag: TA\n---\n\n## Brief Summary\n\nWeb server fingerprinting is the task of identifying the type and version of web server that a target is running on. While web server fingerprinting is often encapsulated in automated testing tools, it is important for researchers to understand the fundamentals of how these tools attempt to identify software, and why this is useful.\n","WSTG-INFO-03":"# Review Webserver Metafiles for Information Leakage\n\n---\nid: WSTG-INFO-03\ntag: TA\n---\n\n## Brief Summary\n\nThis section describes how to test various metadata files for information leakage of the web application's path(s), or functionality. Furthermore, the list of directories that are to be avoided by Spiders, Robots, or Crawlers can also be created as a dependency for [Map execution paths through application](07-Map_Execution_Paths_Through_Application.md).\n","WSTG-INFO-04":"# Enumerate Applications on Webserver\n\n---\nid: WSTG-INFO-04\ntag: TA\n---\n\n## Brief Summary\n\nA paramount step in testing for web application vulnerabilities is to find out which particular applications are hosted on a web server. Many applications have known vulnerabilities and known attack strategies that can be exploited in order to gain remote control or to exploit data.\n","WSTG-INFO-05":"# Review Webpage Content for Information Leakage\n\n---\nid: WSTG-INFO-05\ntag: TA\n---\n\n## Brief Summary\n\nIt is very common, and even recommended, for programmers to include detailed comments and metadata on their source code. However, comments and metadata included into the HTML code might reveal internal information that should not be available to potential attackers. Comments and metadata review should be done in order to determine if any information is being leaked.\n","WSTG-INFO-06":"# Identify Application Entry Points\n\n---\nid: WSTG-INFO-06\ntag: TA\n---\n\n## Brief Summary\n\nEnumerating the application and its attack surface is a key precursor before any thorough testing can be undertaken, as it allows the tester to identify likely areas of weakness. This section aims to help identify and map out areas within the application that should be investigated once enumeration and mapping have been completed.\n","WSTG-INFO-07":"# Map Execution Paths Through Application\n\n---\nid: WSTG-INFO-07\ntag: TA\n---\n\n## Brief Summary\n\nBefore commencing security testing, understanding the structure of the application is paramount. Without a thorough understanding of the layout of the application, it is unlikely that it will be tested thoroughly.\n","WSTG-INFO-08":"# Fingerprint Web Application Framework\n\n---\nid: WSTG-INFO-08\ntag: TA\n---\n\n## Brief Summary\n\nThere is nothing new under the sun, and nearly every web application that one may think of developing has already been developed. With the vast number of free and Open Source software projects that are actively developed and deployed around the world, it is very likely that an application security test will face a target that is entirely or partly dependent on these well known applications or fram\n","WSTG-INFO-09":"# Fingerprint Web Application\n\n---\nid: WSTG-INFO-09\ntag: TA\n---\n\n## Brief Summary\n\nThis test checks for security vulnerabilities in the application.\n","WSTG-INFO-10":"# Map Application Architecture\n\n---\nid: WSTG-INFO-10\ntag: TA\n---\n\n## Brief Summary\n\nThe complexity of interconnected and heterogeneous web infrastructure can include hundreds of web applications and makes configuration management and review a fundamental step in testing and deploying every single application.\n","WSTG-CONF-01":"# Test Network Infrastructure Configuration\n\n---\nid: WSTG-CONF-01\ntag: TA\n---\n\n## Brief Summary\n\nThe intrinsic complexity of interconnected and heterogeneous web server infrastructure, which can include hundreds of web applications, makes configuration management and review a fundamental step in testing and deploying every single application.\n","WSTG-CONF-02":"# Test Application Platform Configuration\n\n---\nid: WSTG-CONF-02\ntag: TA\n---\n\n## Brief Summary\n\nProper configuration of the single elements that make up an application architecture is important in order to prevent mistakes that might compromise the security of the whole architecture. Configuration review and testing is a critical task in creating and maintaining an architecture.\n","WSTG-CONF-03":"# Test File Extensions Handling for Sensitive Information\n\n---\nid: WSTG-CONF-03\ntag: TA\n---\n\n## Brief Summary\n\nFile extensions are commonly used in web servers to easily determine which technologies, languages and plugins must be used to fulfill the web request. While this behavior is consistent with RFCs and Web Standards, using standard file extensions provides the penetration tester useful information about the underlying technologies used in a web appliance and greatly simplifies the task of determinin\n","WSTG-CONF-04":"# Review Old Backup and Unreferenced Files for Sensitive Information\n\n---\nid: WSTG-CONF-04\ntag: TA\n---\n\n## Brief Summary\n\nWhile most of the files within a web server are directly handled by the server itself, it isn't uncommon to find unreferenced or forgotten files that can be used to obtain important information about the infrastructure or the credentials.\n","WSTG-CONF-05":"# Enumerate Infrastructure and Application Admin Interfaces\n\n---\nid: WSTG-CONF-05\ntag: TA\n---\n\n## Brief Summary\n\nAdministrator interfaces may be present in the application or on the application server to allow certain users to undertake privileged activities on the site. Tests should be undertaken to reveal if and how this privileged functionality can be accessed by an unauthorized or standard user.\n","WSTG-CONF-06":"# Test HTTP Methods\n\n---\nid: WSTG-CONF-06\ntag: TA\n---\n\n## Brief Summary\n\nHTTP offers a number of methods that can be used to perform actions on the web server (the HTTP 1.1 standard refers to them as `methods` but they are also commonly described as `verbs`). While GET and POST are by far the most common methods that are used to access information provided by a web server, HTTP allows several other (and somewhat less known) methods.\n","WSTG-CONF-07":"# Test HTTP Strict Transport Security\n\n---\nid: WSTG-CONF-07\ntag: TA\n---\n\n## Brief Summary\n\nThe HTTP Strict Transport Security (HSTS) feature lets a web application inform the browser through the use of a special response header that it should never establish a connection to the specified domain servers using un-encrypted HTTP. Instead, it should automatically establish all connection requests to access the site through HTTPS. It also prevents users from overriding certificate errors.\n","WSTG-CONF-08":"# Test RIA Cross Domain Policy\n\n---\nid: WSTG-CONF-08\ntag: TA\n---\n\n## Brief Summary\n\nRich Internet Applications (RIA) have adopted Adobe's crossdomain.xml policy files to allow for controlled cross domain access to data and service consumption using technologies such as Oracle Java, Silverlight, and Adobe Flash. Therefore, a domain can grant remote access to its services from a different domain.\n","WSTG-CONF-09":"# Test File Permission\n\n---\nid: WSTG-CONF-09\ntag: TA\n---\n\n## Brief Summary\n\nWhen a resource is given a permissions setting that provides access to a wider range of actors than required, it could lead to the exposure of sensitive information, or the modification of that resource by unintended parties. This is especially dangerous when the resource is related to program configuration, execution, or sensitive user data.\n","WSTG-CONF-10":"# Test for Subdomain Takeover\n\n---\nid: WSTG-CONF-10\ntag: TA\n---\n\n## Brief Summary\n\nA successful exploitation of this kind of vulnerability allows an adversary to claim and take control of the victim's subdomain. This attack relies on the following: 1. The victim's external DNS server subdomain record is configured to point to a non-existing or non-active resource/external service/endpoint.\n","WSTG-CONF-11":"# Test Cloud Storage\n\n---\nid: WSTG-CONF-11\ntag: TA\n---\n\n## Brief Summary\n\nCloud storage services facilitate web application and services to store and access objects in the storage service. Improper access control configuration, however, may result in sensitive information exposure, data being tampered, or unauthorized access. A known example is where an Amazon S3 bucket is misconfigured, although the other cloud storage services may also be exposed to similar risks.\n","WSTG-IDNT-01":"# Test Role Definitions\n\n---\nid: WSTG-IDNT-01\ntag: TA\n---\n\n## Brief Summary\n\nApplications have several types of functionalities and services, and those require access permissions based on the needs of the user. That user could be: - an administrator, where they manage the application functionalities. - an auditor, where they review the application transactions and provide a detailed report.\n","WSTG-IDNT-02":"# Test User Registration Process\n\n---\nid: WSTG-IDNT-02\ntag: TA\n---\n\n## Brief Summary\n\nSome websites offer a user registration process that automates (or semi-automates) the provisioning of system access to users. The identity requirements for access vary from positive identification to none at all, depending on the security requirements of the system.\n","WSTG-IDNT-03":"# Test Account Provisioning Process\n\n---\nid: WSTG-IDNT-03\ntag: TA\n---\n\n## Brief Summary\n\nThe provisioning of accounts presents an opportunity for an attacker to create a valid account without application of the proper identification and authorization process.\n","WSTG-IDNT-04":"# Testing for Account Enumeration and Guessable User Account\n\n---\nid: WSTG-IDNT-04\ntag: TA\n---\n\n## Brief Summary\n\nThe scope of this test is to verify if it is possible to collect a set of valid usernames by interacting with the authentication mechanism of the application. This test will be useful for brute force testing, in which the tester verifies if, given a valid username, it is possible to find the corresponding password.\n","WSTG-IDNT-05":"# Testing for Weak or Unenforced Username Policy\n\n---\nid: WSTG-IDNT-05\ntag: TA\n---\n\n## Brief Summary\n\nUser account names are often highly structured (e.g. Joe Bloggs account name is jbloggs and Fred Nurks account name is fnurks) and valid account names can easily be guessed.\n","WSTG-ATHN-01":"# Testing for Credentials Transported over an Encrypted Channel\n\n---\nid: WSTG-ATHN-01\ntag: TA\n---\n\n## Brief Summary\n\nTesting for credentials transport verifies that web applications encrypt authentication data in transit. This encryption prevents attackers from taking over accounts by [sniffing network traffic](https://owasp.org/www-community/attacks/Man-in-the-middle_attack). Web applications use [HTTPS](https://tools.ietf.\n","WSTG-ATHN-02":"# Testing for Default Credentials\n\n---\nid: WSTG-ATHN-02\ntag: TA\n---\n\n## Brief Summary\n\nNowadays web applications often make use of popular Open Source or commercial software that can be installed on servers with minimal configuration or customization by the server administrator. Moreover, a lot of hardware appliances (i.e. network routers and database servers) offer web-based configuration or administrative interfaces.\n","WSTG-ATHN-03":"# Testing for Weak Lock Out Mechanism\n\n---\nid: WSTG-ATHN-03\ntag: TA\n---\n\n## Brief Summary\n\nAccount lockout mechanisms are used to mitigate brute force attacks. Some of the attacks that can be defeated by using lockout mechanism: - Login password or username guessing attack. - Code guessing on any 2FA functionality or Security Questions.\n","WSTG-ATHN-04":"# Testing for Bypassing Authentication Schema\n\n---\nid: WSTG-ATHN-04\ntag: TA\n---\n\n## Brief Summary\n\nIn computer security, authentication is the process of attempting to verify the digital identity of the sender of a communication. A common example of such a process is the log on process. Testing the authentication schema means understanding how the authentication process works and using that information to circumvent the authentication mechanism.\n","WSTG-ATHN-05":"# Testing for Vulnerable Remember Password\n\n---\nid: WSTG-ATHN-05\ntag: TA\n---\n\n## Brief Summary\n\nCredentials are the most widely used authentication technology. Due to such a wide usage of username-password pairs, users are no longer able to properly handle their credentials across the multitude of used applications.\n","WSTG-ATHN-06":"# Testing for Browser Cache Weaknesses\n\n---\nid: WSTG-ATHN-06\ntag: TA\n---\n\n## Brief Summary\n\nIn this phase the tester checks that the application correctly instructs the browser to not retain sensitive data. Browsers can store information for purposes of caching and history. Caching is used to improve performance, so that previously displayed information doesn't need to be downloaded again.\n","WSTG-ATHN-07":"# Testing for Weak Password Policy\n\n---\nid: WSTG-ATHN-07\ntag: TA\n---\n\n## Brief Summary\n\nThe most prevalent and most easily administered authentication mechanism is a static password. The password represents the keys to the kingdom, but is often subverted by users in the name of usability. In each of the recent high profile hacks that have revealed user credentials, it is lamented that most common passwords are still: `123456`, `password` and `qwerty`.\n","WSTG-ATHN-08":"# Testing for Weak Security Question Answer\n\n---\nid: WSTG-ATHN-08\ntag: TA\n---\n\n## Brief Summary\n\nOften called \"secret\" questions and answers, security questions and answers are often used to recover forgotten passwords (see [Testing for weak password change or reset functionalities](09-Testing_for_Weak_Password_Change_or_Reset_Functionalities.md), or as extra security on top of the password.\n","WSTG-ATHN-09":"# Testing for Weak Password Change or Reset Functionalities\n\n---\nid: WSTG-ATHN-09\ntag: TA\n---\n\n## Brief Summary\n\nThe password change and reset function of an application is a self-service password change or reset mechanism for users. This self-service mechanism allows users to quickly change or reset their password without an administrator intervening. When passwords are changed they are typically changed within the application.\n","WSTG-ATHN-10":"# Testing for Weaker Authentication in Alternative Channel\n\n---\nid: WSTG-ATHN-10\ntag: TA\n---\n\n## Brief Summary\n\nEven if the primary authentication mechanisms do not include any vulnerabilities, it may be that vulnerabilities exist in alternative legitimate authentication user channels for the same user accounts. Tests should be undertaken to identify alternative channels and, subject to test scoping, identify vulnerabilities.\n","WSTG-ATHZ-01":"# Testing Directory Traversal File Include\n\n---\nid: WSTG-ATHZ-01\ntag: TA\n---\n\n## Brief Summary\n\nMany web applications use and manage files as part of their daily operation. Using input validation methods that have not been well designed or deployed, an aggressor could exploit the system in order to read or write files that are not intended to be accessible. In particular situations, it could be possible to execute arbitrary code or system commands.\n","WSTG-ATHZ-02":"# Testing for Bypassing Authorization Schema\n\n---\nid: WSTG-ATHZ-02\ntag: TA\n---\n\n## Brief Summary\n\nThis kind of test focuses on verifying how the authorization schema has been implemented for each role or privilege to get access to reserved functions and resources. For every specific role the tester holds during the assessment and for every function and request that the application executes during the post-authentication phase, it is necessary to verify: - Is it possible to access that resource\n","WSTG-ATHZ-03":"# Testing for Privilege Escalation\n\n---\nid: WSTG-ATHZ-03\ntag: TA\n---\n\n## Brief Summary\n\nThis section describes the issue of escalating privileges from one stage to another. During this phase, the tester should verify that it is not possible for a user to modify their privileges or roles inside the application in ways that could allow privilege escalation attacks.\n","WSTG-ATHZ-04":"# Testing for Insecure Direct Object References\n\n---\nid: WSTG-ATHZ-04\ntag: TA\n---\n\n## Brief Summary\n\nInsecure Direct Object References (IDOR) occur when an application provides direct access to objects based on user-supplied input. As a result of this vulnerability attackers can bypass authorization and access resources in the system directly, for example database records or files.\n","WSTG-SESS-01":"# Testing for Session Management Schema\n\n---\nid: WSTG-SESS-01\ntag: TA\n---\n\n## Brief Summary\n\nOne of the core components of any web-based application is the mechanism by which it controls and maintains the state for a user interacting with it. To avoid continuous authentication for each page of a website or service, web applications implement various mechanisms to store and validate credentials for a pre-determined timespan. These mechanisms are known as Session Management.\n","WSTG-SESS-02":"# Testing for Cookies Attributes\n\n---\nid: WSTG-SESS-02\ntag: TA\n---\n\n## Brief Summary\n\nWeb Cookies (herein referred to as cookies) are often a key attack vector for malicious users (typically targeting other users) and the application should always take due diligence to protect cookies. HTTP is a stateless protocol, meaning that it doesn't hold any reference to requests being sent by the same user. In order to fix this issue, sessions were created and appended to HTTP requests.\n","WSTG-SESS-03":"# Testing for Session Fixation\n\n---\nid: WSTG-SESS-03\ntag: TA\n---\n\n## Brief Summary\n\nSession fixation is enabled by the insecure practice of preserving the same value of the session cookies before and after authentication. This typically happens when session cookies are used to store state information even before login, e.g., to add items to a shopping cart before authenticating for payment.\n","WSTG-SESS-04":"# Testing for Exposed Session Variables\n\n---\nid: WSTG-SESS-04\ntag: TA\n---\n\n## Brief Summary\n\nThe Session Tokens (Cookie, SessionID, Hidden Field), if exposed, will usually enable an attacker to impersonate a victim and access the application illegitimately. It is important that they are protected from eavesdropping at all times, particularly whilst in transit between the client browser and the application servers.\n","WSTG-SESS-05":"# Testing for Cross Site Request Forgery\n\n---\nid: WSTG-SESS-05\ntag: TA\n---\n\n## Brief Summary\n\nCross-Site Request Forgery ([CSRF](https://owasp.org/www-community/attacks/csrf)) is an attack that forces an end user to execute unintended actions on a web application in which they are currently authenticated. With a little social engineering help (like sending a link via email or chat), an attacker may force the users of a web application to execute actions of the attacker's choosing.\n","WSTG-SESS-06":"# Testing for Logout Functionality\n\n---\nid: WSTG-SESS-06\ntag: TA\n---\n\n## Brief Summary\n\nSession termination is an important part of the session lifecycle. Reducing to a minimum the lifetime of the session tokens decreases the likelihood of a successful session hijacking attack. This can be seen as a control against preventing other attacks like Cross Site Scripting and Cross Site Request Forgery.\n","WSTG-SESS-07":"# Testing Session Timeout\n\n---\nid: WSTG-SESS-07\ntag: TA\n---\n\n## Brief Summary\n\nIn this phase testers check that the application automatically logs out a user when that user has been idle for a certain amount of time, ensuring that it is not possible to \"reuse\" the same session and that no sensitive data remains stored in the browser cache. All applications should implement an idle or inactivity timeout for sessions.\n","WSTG-SESS-08":"# Testing for Session Puzzling\n\n---\nid: WSTG-SESS-08\ntag: TA\n---\n\n## Brief Summary\n\nSession Variable Overloading (also known as Session Puzzling) is an application level vulnerability which can enable an attacker to perform a variety of malicious actions, including but not limited to: - Bypass efficient authentication enforcement mechanisms, and impersonate legitimate users.\n","WSTG-SESS-09":"# Testing for Session Hijacking\n\n---\nid: WSTG-SESS-09\ntag: TA\n---\n\n## Brief Summary\n\nAn attacker who gets access to user session cookies can impersonate them by presenting such cookies. This attack is known as session hijacking. When considering network attackers, i.e., attackers who control the network used by the victim, session cookies can be unduly exposed to the attacker over HTTP.\n","WSTG-INPV-01":"# Testing for Reflected Cross Site Scripting\n\n---\nid: WSTG-INPV-01\ntag: TA\n---\n\n## Brief Summary\n\nReflected [Cross-site Scripting (XSS)](https://owasp.org/www-community/attacks/xss/) occur when an attacker injects browser executable code within a single HTTP response. The injected attack is not stored within the application itself; it is non-persistent and only impacts users who open a maliciously crafted link or third-party web page.\n","WSTG-INPV-02":"# Testing for Stored Cross Site Scripting\n\n---\nid: WSTG-INPV-02\ntag: TA\n---\n\n## Brief Summary\n\nStored [Cross-site Scripting (XSS)](https://owasp.org/www-community/attacks/xss/) is the most dangerous type of Cross Site Scripting. Web applications that allow users to store data are potentially exposed to this type of attack. This chapter illustrates examples of stored cross site scripting injection and related exploitation scenarios.\n","WSTG-INPV-03":"# Testing for HTTP Verb Tampering\n\n---\nid: WSTG-INPV-03\ntag: TA\n---\n\n## Brief Summary\n\nThis test checks for security vulnerabilities in the application.\n","WSTG-INPV-04":"# Testing for HTTP Parameter Pollution\n\n---\nid: WSTG-INPV-04\ntag: TA\n---\n\n## Brief Summary\n\nHTTP Parameter Pollution tests the applications response to receiving multiple HTTP parameters with the same name; for example, if the parameter `username` is included in the GET or POST parameters twice. Supplying multiple HTTP parameters with the same name may cause an application to interpret values in unanticipated ways.\n","WSTG-INPV-05":"# Testing for SQL Injection\n\n---\nid: WSTG-INPV-05\ntag: TA\n---\n\n## Brief Summary\n\nSQL injection testing checks if it is possible to inject data into the application so that it executes a user-controlled SQL query in the database. Testers find a SQL injection vulnerability if the application uses user input to create SQL queries without proper input validation.\n","WSTG-INPV-06":"# Testing for Oracle\n\n---\nid: WSTG-INPV-06\ntag: TA\n---\n\n## Brief Summary\n\nWeb based PL/SQL applications are enabled by the PL/SQL Gateway, which is is the component that translates web requests into database queries. Oracle has developed a number of software implementations, ranging from the early web listener product to the Apache `mod_plsql` module to the XML Database (XDB) web server.\n","WSTG-INPV-07":"# Testing for MySQL\n\n---\nid: WSTG-INPV-07\ntag: TA\n---\n\n## Brief Summary\n\n[SQL Injection](https://owasp.org/www-community/attacks/SQL_Injection) vulnerabilities occur whenever input is used in the construction of a SQL query without being adequately constrained or sanitized. The use of dynamic SQL (the construction of SQL queries by concatenation of strings) opens the door to these vulnerabilities. SQL injection allows an attacker to access the SQL servers.\n","WSTG-INPV-08":"# Testing for SQL Server\n\n---\nid: WSTG-INPV-08\ntag: TA\n---\n\n## Brief Summary\n\nIn this section some [SQL Injection](https://owasp.org/www-community/attacks/SQL_Injection) techniques that utilize specific features of Microsoft SQL Server will be discussed. SQL injection vulnerabilities occur whenever input is used in the construction of an SQL query without being adequately constrained or sanitized.\n","WSTG-INPV-09":"# Testing PostgreSQL\n\n---\nid: WSTG-INPV-09\ntag: TA\n---\n\n## Brief Summary\n\nIn this section, some SQL Injection techniques for PostgreSQL will be discussed. These techniques have the following characteristics: - PHP Connector allows multiple statements to be executed by using `;` as a statement separator - SQL Statements can be truncated by appending the comment char: `--`.\n","WSTG-INPV-10":"# Testing for MS Access\n\n---\nid: WSTG-INPV-10\ntag: TA\n---\n\n## Brief Summary\n\nAs explained in the generic [SQL injection](https://owasp.org/www-community/attacks/SQL_Injection) section, SQL injection vulnerabilities occur whenever user-supplied input is used during the construction of a SQL query without being adequately constrained or sanitized.\n","WSTG-INPV-11":"# Testing for NoSQL Injection\n\n---\nid: WSTG-INPV-11\ntag: TA\n---\n\n## Brief Summary\n\nNoSQL databases provide looser consistency restrictions than traditional SQL databases. By requiring fewer relational constraints and consistency checks, NoSQL databases often offer performance and scaling benefits. Yet these databases are still potentially vulnerable to injection attacks, even if they aren't using the traditional SQL syntax.\n","WSTG-INPV-12":"# Testing for ORM Injection\n\n---\nid: WSTG-INPV-12\ntag: TA\n---\n\n## Brief Summary\n\n[Object Relational Mapping (ORM) Injection](https://capec.mitre.org/data/definitions/109.html) is an attack using SQL Injection against an ORM generated data access object model. From the point of view of a tester, this attack is virtually identical to a SQL Injection attack. However, the injection vulnerability exists in code generated by the ORM layer.\n","WSTG-INPV-13":"# Testing for Client-side\n\n---\nid: WSTG-INPV-13\ntag: TA\n---\n\n## Brief Summary\n\nClient-side SQL injection occurs when an application implements the [Web SQL Database](https://www.w3.org/TR/webdatabase/) technology and doesn't properly validate the input nor parametrize its query variables. This database is manipulated by using JavaScript (JS) API calls, such as `openDatabase()`, which creates or opens an existing database.\n","WSTG-INPV-14":"# Testing for LDAP Injection\n\n---\nid: WSTG-INPV-14\ntag: TA\n---\n\n## Brief Summary\n\nThe Lightweight Directory Access Protocol (LDAP) is used to store information about users, hosts, and many other objects. [LDAP injection](https://wiki.owasp.org/index.php/LDAP_injection) is a server-side attack, which could allow sensitive information about users and hosts represented in an LDAP structure to be disclosed, modified, or inserted.\n","WSTG-INPV-15":"# Testing for XML Injection\n\n---\nid: WSTG-INPV-15\ntag: TA\n---\n\n## Brief Summary\n\nXML Injection testing is when a tester tries to inject an XML doc to the application. If the XML parser fails to contextually validate data, then the test will yield a positive result. This section describes practical examples of XML Injection.\n","WSTG-INPV-16":"# Testing for SSI Injection\n\n---\nid: WSTG-INPV-16\ntag: TA\n---\n\n## Brief Summary\n\nWeb servers usually give developers the ability to add small pieces of dynamic code inside static HTML pages, without having to deal with full-fledged server-side or client-side languages. This feature is provided by [Server-Side Includes](https://owasp.org/www-community/attacks/Server-Side_Includes_%28SSI%29_Injection)(SSI).\n","WSTG-INPV-17":"# Testing for XPath Injection\n\n---\nid: WSTG-INPV-17\ntag: TA\n---\n\n## Brief Summary\n\nXPath is a language that has been designed and developed primarily to address parts of an XML document. In XPath injection testing, we test if it is possible to inject XPath syntax into a request interpreted by the application, allowing an attacker to execute user-controlled XPath queries.\n","WSTG-INPV-18":"# Testing for IMAP SMTP Injection\n\n---\nid: WSTG-INPV-18\ntag: TA\n---\n\n## Brief Summary\n\nThis threat affects all applications that communicate with mail servers (IMAP/SMTP), generally webmail applications. The aim of this test is to verify the capacity to inject arbitrary IMAP/SMTP commands into the mail servers, due to input data not being properly sanitized. The IMAP/SMTP Injection technique is more effective if the mail server is not directly accessible from Internet.\n","WSTG-INPV-19":"# Testing for Code Injection\n\n---\nid: WSTG-INPV-19\ntag: TA\n---\n\n## Brief Summary\n\nThis section describes how a tester can check if it is possible to enter code as input on a web page and have it executed by the web server. In [Code Injection](https://owasp.org/www-community/attacks/Code_Injection) testing, a tester submits input that is processed by the web server as dynamic code or as an included file. These tests can target various server-side scripting engines, e.g.\n","WSTG-INPV-20":"# Testing for Local File Inclusion\n\n---\nid: WSTG-INPV-20\ntag: TA\n---\n\n## Brief Summary\n\nThe File Inclusion vulnerability allows an attacker to include a file, usually exploiting a \"dynamic file inclusion\" mechanisms implemented in the target application. The vulnerability occurs due to the use of user-supplied input without proper validation.\n","WSTG-INPV-21":"# Testing for Remote File Inclusion\n\n---\nid: WSTG-INPV-21\ntag: TA\n---\n\n## Brief Summary\n\nThe File Inclusion vulnerability allows an attacker to include a file, usually exploiting a \"dynamic file inclusion\" mechanisms implemented in the target application. The vulnerability occurs due to the use of user-supplied input without proper validation.\n","WSTG-INPV-22":"# Testing for Command Injection\n\n---\nid: WSTG-INPV-22\ntag: TA\n---\n\n## Brief Summary\n\nThis article describes how to test an application for OS command injection. The tester will try to inject an OS command through an HTTP request to the application. OS command injection is a technique used via a web interface in order to execute OS commands on a web server.\n","WSTG-INPV-23":"# Testing for Format String Injection\n\n---\nid: WSTG-INPV-23\ntag: TA\n---\n\n## Brief Summary\n\nA format string is a null-terminated character sequence that also contains conversion specifiers interpreted or converted at runtime. If server-side code [concatenates a user's input with a format string](https://www.netsparker.\n","WSTG-INPV-24":"# Testing for Incubated Vulnerability\n\n---\nid: WSTG-INPV-24\ntag: TA\n---\n\n## Brief Summary\n\nAlso often referred to as persistent attacks, incubated testing is a complex testing method that needs more than one data validation vulnerability to work. Incubated vulnerabilities are typically used to conduct \"watering hole\" attacks against users of legitimate web applications.\n","WSTG-INPV-25":"# Testing for HTTP Splitting Smuggling\n\n---\nid: WSTG-INPV-25\ntag: TA\n---\n\n## Brief Summary\n\nThis section illustrates examples of attacks that leverage specific features of the HTTP protocol, either by exploiting weaknesses of the web application or peculiarities in the way different agents interpret HTTP messages.\n","WSTG-INPV-26":"# Testing for HTTP Incoming Requests\n\n---\nid: WSTG-INPV-26\ntag: TA\n---\n\n## Brief Summary\n\nThis section describes how to monitor all incoming/outgoing HTTP requests on both client-side or server-side. The purpose of this testing is to verify if there is unnecessary or suspicious HTTP request sending in the background. Most of Web security testing tools (i.e.\n","WSTG-INPV-27":"# Testing for Host Header Injection\n\n---\nid: WSTG-INPV-27\ntag: TA\n---\n\n## Brief Summary\n\nA web server commonly hosts several web applications on the same IP address, referring to each application via the virtual host. In an incoming HTTP request, web servers often dispatch the request to the target virtual host based on the value supplied in the Host header.\n","WSTG-INPV-28":"# Testing for Server-side Template Injection\n\n---\nid: WSTG-INPV-28\ntag: TA\n---\n\n## Brief Summary\n\nWeb applications commonly use server-side templating technologies (Jinja2, Twig, FreeMaker, etc.) to generate dynamic HTML responses. Server-side Template Injection vulnerabilities (SSTI) occur when user input is embedded in a template in an unsafe manner and results in remote code execution on the server.\n","WSTG-INPV-29":"# Testing for Server-Side Request Forgery\n\n---\nid: WSTG-INPV-29\ntag: TA\n---\n\n## Brief Summary\n\nWeb applications often interact with internal or external resources. While you may expect that only the intended resource will be handling the data you send, improperly handled data may create a situation where injection attacks are possible. One type of injection attack is called Server-side Request Forgery (SSRF).\n","WSTG-ERRH-01":"# Testing for Improper Error Handling\n\n---\nid: WSTG-ERRH-01\ntag: TA\n---\n\n## Brief Summary\n\nAll types of applications (web apps, web servers, databases, etc.) will generate errors for various reasons. Developers often ignore handling these errors, or push away the idea that a user will ever try to trigger an error purposefully (*e.g.* sending a string where an integer is expected).\n","WSTG-ERRH-02":"# Testing for Stack Traces\n\n---\nid: WSTG-ERRH-02\ntag: TA\n---\n\n## Brief Summary\n\nThis test checks for security vulnerabilities in the application.\n","WSTG-CRYP-01":"# Testing for Weak Transport Layer Security\n\n---\nid: WSTG-CRYP-01\ntag: TA\n---\n\n## Brief Summary\n\nWhen information is sent between the client and the server, it must be encrypted and protected in order to prevent an attacker from being able to read or modify it. This is most commonly done using HTTPS, which uses the [Transport Layer Security (TLS)](https://en.wikipedia.org/wiki/Transport_Layer_Security) protocol, a replacement for the older Secure Socket Layer (SSL) protocol.\n","WSTG-CRYP-02":"# Testing for Padding Oracle\n\n---\nid: WSTG-CRYP-02\ntag: TA\n---\n\n## Brief Summary\n\nA padding oracle is a function of an application which decrypts encrypted data provided by the client, e.g. internal session state stored on the client, and leaks the state of the validity of the padding after decryption. The existence of a padding oracle allows an attacker to decrypt encrypted data and encrypt arbitrary data without knowledge of the key used for these cryptographic operations.\n","WSTG-CRYP-03":"# Testing for Sensitive Information Sent via Unencrypted Channels\n\n---\nid: WSTG-CRYP-03\ntag: TA\n---\n\n## Brief Summary\n\nSensitive data must be protected when it is transmitted through the network. If data is transmitted over HTTPS or encrypted in another way the protection mechanism must not have limitations or vulnerabilities, as explained in the broader article [Testing for Weak Transport Layer Security](01-Testing_for_Weak_Transport_Layer_Security.\n","WSTG-CRYP-04":"# Testing for Weak Encryption\n\n---\nid: WSTG-CRYP-04\ntag: TA\n---\n\n## Brief Summary\n\nIncorrect uses of encryption algorithms may result in sensitive data exposure, key leakage, broken authentication, insecure session, and spoofing attacks. There are some encryption or hash algorithms known to be weak and are not suggested for use such as MD5 and RC4.\n","WSTG-BUSL-00":"# WSTG-BUSL-00: Introduction to Business Logic\n\n---\nid: WSTG-BUSL-00\ntag: TA\n---\n\n## Brief Summary\n\nThis test checks for security vulnerabilities in the application.\n","WSTG-BUSL-02":"# Test Business Logic Data Validation\n\n---\nid: WSTG-BUSL-02\ntag: TA\n---\n\n## Brief Summary\n\nThe application must ensure that only logically valid data can be entered at the front end as well as directly to the server-side of an application of system. Only verifying data locally may leave applications vulnerable to server injections through proxies or at handoffs with other systems.\n","WSTG-BUSL-03":"# Test Ability to Forge Requests\n\n---\nid: WSTG-BUSL-03\ntag: TA\n---\n\n## Brief Summary\n\nForging requests is a method that attackers use to circumvent the front end GUI application to directly submit information for back end processing. The goal of the attacker is to send HTTP POST/GET requests through an intercepting proxy with data values that is not supported, guarded against or expected by the applications business logic.\n","WSTG-BUSL-04":"# Test Integrity Checks\n\n---\nid: WSTG-BUSL-04\ntag: TA\n---\n\n## Brief Summary\n\nMany applications are designed to display different fields depending on the user of situation by leaving some inputs hidden. However, in many cases it is possible to submit values hidden field values to the server using a proxy.\n","WSTG-BUSL-05":"# Test for Process Timing\n\n---\nid: WSTG-BUSL-05\ntag: TA\n---\n\n## Brief Summary\n\nIt is possible that attackers can gather information on an application by monitoring the time it takes to complete a task or give a respond. Additionally, attackers may be able to manipulate and break designed business process flows by simply keeping active sessions open and not submitting their transactions in the \"expected\" time frame.\n","WSTG-BUSL-06":"# Test Number of Times a Function Can Be Used Limits\n\n---\nid: WSTG-BUSL-06\ntag: TA\n---\n\n## Brief Summary\n\nMany of the problems that applications are solving require limits to the number of times a function can be used or action can be executed. Applications must be \"smart enough\" to not allow the user to exceed their limit on the use of these functions since in many cases each time the function is used the user may gain some type of benefit that must be accounted for to properly compensate the owner.\n","WSTG-BUSL-07":"# Testing for the Circumvention of Work Flows\n\n---\nid: WSTG-BUSL-07\ntag: TA\n---\n\n## Brief Summary\n\nWorkflow vulnerabilities involve any type of vulnerability that allows the attacker to misuse an application/system in a way that will allow them to circumvent (not follow) the designed/intended workflow. [Definition of a workflow on Wikipedia](https://en.wikipedia.\n","WSTG-BUSL-08":"# Test Defenses Against Application Misuse\n\n---\nid: WSTG-BUSL-08\ntag: TA\n---\n\n## Brief Summary\n\nThe misuse and invalid use of of valid functionality can identify attacks attempting to enumerate the web application, identify weaknesses, and exploit vulnerabilities. Tests should be undertaken to determine whether there are application-layer defensive mechanisms in place to protect the application. The lack of active defenses allows an attacker to hunt for vulnerabilities without any recourse.\n","WSTG-BUSL-09":"# Test Upload of Unexpected File Types\n\n---\nid: WSTG-BUSL-09\ntag: TA\n---\n\n## Brief Summary\n\nMany applications' business processes allow for the upload and manipulation of data that is submitted via files. But the business process must check the files and only allow certain \"approved\" file types. Deciding what files are \"approved\" is determined by the business logic and is application/system specific.\n","WSTG-BUSL-10":"# Test Upload of Malicious Files\n\n---\nid: WSTG-BUSL-10\ntag: TA\n---\n\n## Brief Summary\n\nMany applicationâ€™s business processes allow users to upload data to them. Although input validation is widely understood for text-based input fields, it is more complicated to implement when files are accepted.\n","WSTG-CLNT-01":"# Testing for DOM-Based Cross Site Scripting\n\n---\nid: WSTG-CLNT-01\ntag: TA\n---\n\n## Brief Summary\n\n[DOM-based cross-site scripting](https://owasp.org/www-community/attacks/DOM_Based_XSS) is the de-facto name for [XSS](https://owasp.org/www-community/attacks/xss/) bugs that are the result of active browser-side content on a page, typically JavaScript, obtaining user input through a [source](https://github.com/wisec/domxsswiki/wiki/sources) and using it in a [sink](https://github.\n","WSTG-CLNT-02":"# Testing for JavaScript Execution\n\n---\nid: WSTG-CLNT-02\ntag: TA\n---\n\n## Brief Summary\n\nA JavaScript injection vulnerability is a subtype of cross site scripting (XSS) that involves the ability to inject arbitrary JavaScript code that is executed by the application inside the victim's browser.\n","WSTG-CLNT-03":"# Testing for HTML Injection\n\n---\nid: WSTG-CLNT-03\ntag: TA\n---\n\n## Brief Summary\n\nHTML injection is a type of injection vulnerability that occurs when a user is able to control an input point and is able to inject arbitrary HTML code into a vulnerable web page. This vulnerability can have many consequences, like disclosure of a user's session cookies that could be used to impersonate the victim, or, more generally, it can allow the attacker to modify the page content seen by th\n","WSTG-CLNT-04":"# Testing for Client-side URL Redirect\n\n---\nid: WSTG-CLNT-04\ntag: TA\n---\n\n## Brief Summary\n\nThis section describes how to check for client-side URL redirection, also known as open redirection. It is an input validation flaw that exists when an application accepts user-controlled input that specifies a link which leads to an external URL that could be malicious. This kind of vulnerability could be used to accomplish a phishing attack or redirect a victim to an infection page.\n","WSTG-CLNT-05":"# Testing for CSS Injection\n\n---\nid: WSTG-CLNT-05\ntag: TA\n---\n\n## Brief Summary\n\nA CSS Injection vulnerability involves the ability to inject arbitrary CSS code in the context of a trusted web site which is rendered inside a victim's browser. The impact of this type of vulnerability varies based on the supplied CSS payload. It may lead to cross site scripting or data exfiltration.\n","WSTG-CLNT-06":"# Testing for Client-side Resource Manipulation\n\n---\nid: WSTG-CLNT-06\ntag: TA\n---\n\n## Brief Summary\n\nA client-side resource manipulation vulnerability is an input validation flaw. It occurs when an application accepts user-controlled input that specifies the path of a resource such as the source of an iframe, JavaScript, applet, or the handler of an XMLHttpRequest. This vulnerability consists of the ability to control the URLs that link to some resources present in a web page.\n","WSTG-CLNT-07":"# Testing Cross Origin Resource Sharing\n\n---\nid: WSTG-CLNT-07\ntag: TA\n---\n\n## Brief Summary\n\n[Cross origin resource sharing](https://en.wikipedia.org/wiki/Cross-origin_resource_sharing) (CORS) is a mechanism that enables a web browser to perform cross-domain requests using the XMLHttpRequest L2 API in a controlled manner. In the past, the XMLHttpRequest L1 API only allowed requests to be sent within the same origin as it was restricted by the same origin policy.\n","WSTG-CLNT-08":"# Testing for Cross Site Flashing\n\n---\nid: WSTG-CLNT-08\ntag: TA\n---\n\n## Brief Summary\n\nActionScript, based on ECMAScript, is the language used by Flash applications when dealing with interactive needs. There are three versions of the ActionScript language. ActionScript 1.0 and ActionScript 2.0 are very similar with ActionScript 2.0 being an extension of ActionScript 1.0.\n","WSTG-CLNT-09":"# Testing for Clickjacking\n\n---\nid: WSTG-CLNT-09\ntag: TA\n---\n\n## Brief Summary\n\nClickjacking, a subset of UI redressing, is a malicious technique whereby a web user is deceived into interacting (in most cases by clicking) with something other than what the user believes they are interacting with.\n","WSTG-CLNT-10":"# Testing WebSockets\n\n---\nid: WSTG-CLNT-10\ntag: TA\n---\n\n## Brief Summary\n\nTraditionally, the HTTP protocol only allows one request/response per TCP connection. Asynchronous JavaScript and XML (AJAX) allows clients to send and receive data asynchronously (in the background without a page refresh) to the server, however, AJAX requires the client to initiate the requests and wait for the server responses (half-duplex). [WebSockets](https://html.spec.whatwg.\n","WSTG-CLNT-11":"# Testing Web Messaging\n\n---\nid: WSTG-CLNT-11\ntag: TA\n---\n\n## Brief Summary\n\nWeb Messaging (also known as [Cross Document Messaging](https://html.spec.whatwg.org/multipage/web-messaging.html#web-messaging)) allows applications running on different domains to communicate in a secure manner. Before the introduction of web messaging, the communication of different origins (between iframes, tabs and windows) was restricted by the same origin policy and enforced by the browser.\n","WSTG-CLNT-12":"# Testing Browser Storage\n\n---\nid: WSTG-CLNT-12\ntag: TA\n---\n\n## Brief Summary\n\nBrowsers provide the following client-side storage mechanisms for developers to store and retrieve data: - Local Storage - Session Storage - IndexedDB - Web SQL (Deprecated) - Cookies These storage mechanisms can be viewed and edited using the browser's developer tools, such as [Google Chrome DevTools](https://developers.google.\n","WSTG-CLNT-13":"# Testing for Cross Site Script Inclusion\n\n---\nid: WSTG-CLNT-13\ntag: TA\n---\n\n## Brief Summary\n\nCross Site Script Inclusion (XSSI) vulnerability allows sensitive data leakage across-origin or cross-domain boundaries. Sensitive data could include authentication-related data (login states, cookies, auth tokens, session IDs, etc.) or user's personal or sensitive personal data (email addresses, phone numbers, credit card details, social security numbers, etc.).\n","WSTG-API-01":"# WSTG-API-01: Testing GraphQL\n\n---\nid: WSTG-API-01\ntag: TA\n---\n\n## Brief Summary\n\nThis test checks for security vulnerabilities in the application.\n"}